import { Vector } from "./vector";
import { Utils } from "./utils";

export class Rock { 
	p = new Vector(0,0); 	// Position Vector
    v = new Vector(0,0);  // Velocity Vector
    points = [];            // Points (autogenerated)


    constructor(game, position){
		this.game = game;
		// If position not passed, generate random position
		// else, use passed position
		if(position == undefined){
			while(true){
				let x = (Math.random() * game.camera.width*3) - game.camera.width;
				let y = (Math.random() * game.camera.height*3) - game.camera.height;
				if(!(x > 0 && x < game.camera.width && y > 0 && y < game.camera.height)){
					this.p.x = game.rocket.p.x + x - game.camera.width/2;
					this.p.y = game.rocket.p.y + y - game.camera.height/2;
					break;
				}

			}
		} else {
			this.p = position.copy();
		}


        // Constructing random rock figure
        let r = Math.random()*15+10; // approx. radius

		this.sr = r;
		let individualRadii = []; // Each lines length (radius) is kept track to find the average radius of the rock
        for(let i = 0; i < 6; i+=6/9){
            let individualRadius = r + ( (Math.random()*r)-(r/2) );
            let x = Math.sin(i)*individualRadius;
            let y = Math.cos(i)*individualRadius;
			individualRadii.push(individualRadius);
            this.points.push(new Vector(x,y));
        }

		let sum = 0;
		individualRadii.forEach((indR) => {
			sum += indR;
		});
		this.radius = sum / (individualRadii.length); //average



        // Initial velocity
		// This calculation tries to throw the rock towards the rocket, but a slight probablity of deviating
		// I tried using desmos for a probability function, it really isn't necessary, I was just trying it for fun
		let angle = Math.abs(Utils.getAngleBetweenPoints(this.p, game.rocket.p));
		let x = Math.random()*100
		// This formula       â†“       just tries to get a value as close to angle
		let rockAngle = (angle - (50-x)^2)
        let f = Utils.getForceByAngle(rockAngle);
        this.v.x = f.x;
        this.v.y = f.y;

    }


    update(){
		this.p.addApply(this.v);
    }

    draw(){
		this.game.camera.drawPath(this.p, this.points, "stroke");
		return;
		//debug
		/*
		game.ctx.beginPath();
		game.ctx.arc(this.p.x, this.p.y, this.sr, 0, Math.PI*2);
		game.ctx.stroke();
		game.ctx.beginPath();
		game.ctx.strokeStyle = "lightgreen";
		game.ctx.arc(this.p.x, this.p.y, this.radius, 0, Math.PI*2);
		game.ctx.stroke();
		game.ctx.closePath();
		game.ctx.strokeStyle= "white";
		*/
    }
}