
class Camera { // {{{


	target = new Vector(0,0);
	constructor(x,y,width,height){
		this.p = new Vector(x,y);
		this.width = width;
		this.height = height;
	}

	update(){
		this.p.x += (this.target.x - this.p.x - this.width/2) * 0.3;
		this.p.y += (this.target.y - this.p.y - this.height/2) * 0.3;
	}

	calcPos(vect){
		// Returns a calculated position that translates world positions to screen positions with respect to this camera
		return vect.subtract(this.p);
	}
} // }}}

class Rocket { //{{{
    points = [new Vector(15,0), new Vector(-15,-12), new Vector(-15,12)];
    
	// the points are aligned horizontally, resulting in the rocket to be facing right side
    rotation = 270;

	p = new Vector(0,0); // Position   (initialised in constructor)
    v = new Vector(0,0); // Velocity
    a = new Vector(0,0); // Acceleration

	friction = 1.05;
	bullets = [];

    constructor(x,y){
        this.p = new Vector(canvas.width/2, canvas.height/2);
    }

    update(elapsed){
		this.a.set(0,0);

		this.v.divideApply(this.friction);
		
        //this.v.y /= this.friction;
        //this.v.x /= this.friction; 

        if(key[38] == true){
            // Thrust forward
            let thrustAcc = Utils.getForceByAngle(this.rotation);
			this.a = thrustAcc.copy();
        }else {
			this.a.set(0,0);
        }
        if(key[37] == true){
            this.rotation -= 5;
            if(this.rotation < 0){this.rotation += 360}
        }
        if(key[39] == true){
            this.rotation += 5;
            if(this.rotation >= 360){this.rotation -= 360}
        }

		// updating all bullets
		for(let i = 0; i < this.bullets.length; i++){
			this.bullets[i].p.addApply(this.bullets[i].v);

			this.bullets[i].p.multiplyApply(0.99);

			this.bullets[i].timeRemaining -= elapsed;

			if(this.bullets[i].timeRemaining < 0){
				this.bullets.splice(i, 1);
				i -= 1;
			}

		}

		this.v.addApply(this.a);
		this.p.addApply(this.v);
    }

	shoot(angle){
		let force = Utils.getForceByAngle(angle);
		force.multiplyApply(30);


		this.bullets.push({
			p: this.p.copy(),
			v: force,
			timeRemaining: 7000,
		});
	}

    draw (){
        let points = Utils.rotatePoints(this.points, Math.PI/180 * this.rotation);
        Utils.DrawPoints(this.p, points, ctx, "stroke");
		
		// drawing all bullets
		for(let i = 0; i < this.bullets.length; i++){
			ctx.beginPath();
			let bulletPos = game.camera.calcPos(this.bullets[i].p);
			ctx.arc(bulletPos.x, bulletPos.y, 5, 0, Math.PI*2);
			ctx.fill();
			ctx.closePath();
		}
    }
}
// }}}
class Rock { // {{{
    p = [];                 // Position Vector
    v = new Vector(0,0);  // Velocity Vector
    points = [];            // Points (autogenerated)

    constructor(game){
        let x,y = 0;
        if(Math.random()>=0.5){
            x = -(Math.random()*100);
        } else {
            x = canvas.width + (Math.random()*100);
        }
        if(Math.random()>=0.5){
            y = -(Math.random()*100);
        } else {
            y = canvas.height + (Math.random()*100);
        }
        this.p = new Vector(x,y);

        
        let r = Math.random()*30+10; // approx. radius

        // Constructing random rock figure
        for(let i = 0; i < 6; i+=0.7){
            let x = Math.sin(i)*r;
            let y = Math.cos(i)*r;
            let a =Math.random();
            x += a*x
            y += a*y
            this.points.push(new Vector(
                x,y
            ));
        }


        // Initial velocity
        let f = Utils.getForceByAngle(Utils.getAngleBetweenPoints(this.p,game.rocket.p));
        this.v.x = f.x;
        this.v.y = f.y;

    }

    update(){
        this.p.x += this.v.x;
        this.p.y += this.v.y;
    }

    draw(){
        Utils.DrawPoints(this.p, this.points, ctx, "stroke");
    }
}
// }}}
